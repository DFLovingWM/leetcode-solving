# 95. 不同的二叉搜索树 II

## 题意

版本1求的是BST数量，这里求的是所有BST。

## 思路

与版本1差不多，都是动态规划：设计函数`f(l, r)`返回结点`l～r`能构成的BST数组。函数体内做的事情差不多：

- (版本1)求数量时，我们用：f(l, i-1) * f(i+1, r)，最后求和
- (版本2)求具体BST时，需要遍历f(l, i-1)中所有左子树、f(i+1, r)中所有右子树，两两组合（二重循环），最后放到一个数组中

不过不同的是，这里的“缓存”需要同时对`l`和`r`进行哈希，即`1~3`和`4~6`虽然构成BST的数量相等、甚至结构也一致，但因为结点的值有偏移，所以也算两个不同的树了。

小问题：既然求BST数组，那么遍历出来的每个树是否都需要深拷贝？答案是：

- 下层结点：不需要拷贝，因为下层结点在DP中只会被求出一次（重复子问题），之后不会对它进行mutate操作。所以可以共用，于是放在cache中的这些结点其实很多是指向相同。
- 本结点：需要拷贝/新建，因为本结点确定后，需要多次对left、right进行赋值，这种mutate操作不能用在同一个引用上。
