# 二叉树

## 引入

二叉树问题，一般都涉及到遍历/搜索：

- BFS/层次遍历（一般是循环写法）
- DFS（递归写法最直观，循环写法也有）
  - 前序
  - 中序
  - 后序

本笔记探索DFS的循环写法。

## 与BFS的联系

BFS一般使用循环写法，会用到【队列】这个数据结构。其实，如果不考虑前中后序，DFS的循环写法几乎跟BFS是一样的，只需要修改两个地方：

- 数据结构：BFS使用queue，而DFS使用stack（实际上，DFS如果使用递归写法，本质上就是个stack）
- 当前结点：BFS每次取首元素`queue.front()`，而DFS取尾元素`stack.top()`

所以最简单的DFS循环写法，可以由BFS稍微变化而来。感觉挺神奇的！

## 具体思路

> 思路1：模拟遍历路径，用stack保存待遍历结点

假如此时栈顶结点为A，就表示当前遍历到A。因为前、中、后序的区别就在于第几次回溯到A时才处理A这个结点。比如：

- 前序：第1次来到A，就输出A
- 中序：第2次来（回）到A，输出A
- 后序：第3次来（回）到A，才输出A

那么我们需要用一些手段来记录，当前遍历到A结点，属于第几次来到A，否则整个遍历过程就出错了，引发死循环。这些手段有：

- 删边法（cut）：当从左子结点B回溯到A时，就删除A、B之间的边，这样A只剩下右子结点C，下次又遍历到A时，就能发现这是第2次来到A了。同理当从C回到A时，需要删除A、C的边，下次遍历A就知道这是第3次来到A。试想如果不删除边，则A永远检测到有左结点B存在，然后走左边，一直重复该过程。
- 标记法（mark）：“删边法”修改了树结构，这里提出的“标记法”则是用额外的哈希结构（比如HashSet）来标记哪些结点已经走过。比如还是这个例子，如果A要走左边B，那么先将B标记为“已走过”，那么下次回到A时，看到B已经被标记，就不会再重复走B这边了。

> 思路2：stack只保存某些结点

因为思路1中，所有结点都经过栈。对于栈顶A来说，需要判断当前是第几次来到A，主要也是处理这一步。我们可以想想为何要把A入栈，那是因为我们实际遍历（比如中序）时，遍历完B所在子树、C所在子树后，都需要回溯到A，那么这个回溯在stack模拟中，就是把它入栈待用。那如果不把A入栈呢？这样岂不是不需要多次遍历A了么？这个新思路是对的。

- 中序：始终保证左子结点优先，入栈的全是左结点。对于根和每一个右结点A，如果存在左结点，则需要循环地把A的左结点B、B的左结点C、C的左结点D……依次入栈。然后之后出栈时，输出路径、同时又检测右结点。
- 前序：类似地，始终保证中间结点优先，入栈的也全是左结点。对于根和每一个右结点A，如果存在左结点B，先将A输出路径、同时循环地将当前能获取的全部左结点依次入栈。之后出栈时，又检测右结点。

> 思路3：Morris（莫里斯）遍历

上面两种思路都需要用到stack来保存某些结点，因为有“回溯”的必要。而Morris遍历法：

- 算法：首先它会修改树结构，通过对结点A增加right边、可以连接到下一个即将遍历的结点B
- 结果：使得整个树变为接近单链表的“线索二叉树”结构，即每个结点都能通过right来找到下一个结点，这样省掉了stack或者递归的空间，达到O(1)空间复杂度。

对于前序、中序来说，具体算法为：

- 前序：左子树的最右结点.right = 右结点
- 中序：左子树的最右结点.right = 本结点

## 后序的推导

为什么上述思路中，后序遍历有时会“缺席”呢？因为直接按照思路走的话，后序遍历往往得不出比较好的解法。这时候，可以通过前序遍历来推导后序遍历。假设有二叉树（设为A）：

1. A的前序遍历路径为a
1. A进行二叉树反转，得到二叉树B
1. B的前序路径为b

则有：a和b相反。

所以后序路径，可以通过将原二叉树进行反转后进行前序遍历、然后反转一下路径得到。实际编码中，我们不需要真的将二叉树进行反转，而是对左右结点的操作顺序颠倒即可。
