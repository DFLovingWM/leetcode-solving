# 排序

时间复杂度的分析基于对key(判断大小的字段)的对比次数、以及元素赋值的次数。

## 1. O(N2)

### 1.1 插入排序

重新维护一个有序列表(从1个元素的列表开始，因为1个元素的数组总是有序的)，将(N-1)个数依次加入。插入排序的优点是，在原数组基本有序的情况下速度会很快，因为不怎么需要移动元素(可以看到 Shell Sort 就是利用了这一点)。

- 数组实现(差别不大)
  - 原地修改：需要移动目标位置后边的所有元素
  - 新的有序数组
- 链表实现

### 1.2 选择排序

挑选出max并交换到最后一个位置，这样的过程重复(N-1)次。多次比较，一次赋值。

### 1.3 冒泡排序

从头到尾两两比较把max冒泡到最后一个位置，这样的过程重复(N-1)次。思路上与选择排序很类似，但在实现上为多次比较、多次赋值，所以感觉更繁琐一点。

## 2. O(N1.25)

### 2.1 希尔排序：优化的插入排序

## 3. O(NlogN)

### 3.1 快速排序

基本思路是“分治”：

1. 选定一个pivot，小于pivot的放左边，大于pivot的放右边。（N）
1. 对新的两部分递归。（logN）

有两种实现方式：

- 同向指针法：
- 相对指针法：

写代码时，尤其需要注意控制好【递归终止条件】和【递归调用的下标】。

### 3.2 归并排序

与快排类似，都属于`divide and conquer`思想。不同的是，快排是top-down、pre-order的，而归并排序是bottom-up、post-order的。

它的基本思路是：用O(N)的时间，把两个有序数组串联成新数组。而把子数组变为有序数组的过程用递归来完成，因为单个元素组成的数组就是有序数组(初始状态，在递归的叶子结点处)。

实际编码中，对于每一层递归，都返回一个新的有序数组：

1. 将数组平分为左右两部分，记作L1、R1，递归L1得到有序数组L2、R1得到R2。（logN）
1. 串联两个有序数组L2、R2，得到A2。（N）

所以很明显，这类似于二叉树的post-order，所以是bottom-up的。

### 3.3 堆排序

#### 3.3.1 堆

首先要理解“堆”：是一个有着以下性质的数组（用树描述更直观，但用数组实现会更简单）：

```js
A[n] >= A[2n+1] && A[n] >= A[2n+2] // 当A为最大堆时
```

#### 3.3.2 基本步骤

最大堆和最小堆原理一样。拿最大堆来说：

1. 初始化成最大堆
2. 此时已有最大值，将最大值与尾元素交换位置：最大值放在最后，尾元素参与堆。重复该过程直到所有元素都参与堆。因为是`n-1`次维护，所以整体复杂度：O(NlogN)

#### 3.3.3 时间复杂度

1. 建堆为：O(NlogN)。
2. 每次插入元素并维护堆：O(logN)，这过程需要重复(N-1)次。所以也是：O(NlogN)。

综合起来就是：O(NlogN)
