# 1081. 不同字符的最小子序列

## 思路

- 贪心
- 栈

这里说说贪心思路：假设不同的字母个数为`K`，那么我们需要构造一个长度为`K`的、字典序最小的子序列。对于每个位置`i`，为了保证字典序最小，我们【从`a`开始遍历、直到`z`】，看哪个字母能放在`i`这个位置上，需要满足的条件为：选取【最近的】该字母后，它后面的子串要包含我们还没放置的字母。

比如`cdadabcc`，这里不同的字母有：`abcd`，共4个：

- 第0位
  - a：最近的在`a(2)`，后面的子串为`dabbc`，是可以包括剩余的`bcd`的，所以能选
- 第1位
  - b：`a(2)`之后最近的是`b(5)`，其后子串`cc`不足以包含`cd`（没有`d`），所以不能选
  - c：`a(2)`之后最近的是`c(6)`，其后子串`c`不足以包含`bd`，所以不能选
  - d：`a(2)`之后最近的是`d(3)`，其后子串`abcc`可以包含剩余的`bc`，所以能选
- 第2位
  - b：`d(3)`之后最近是`b(5)`，其后子串`cc`能包含`c`，所以能选
- 第3位
  - c：`b(5)`之后最近是`c(6)`，其后子串`cc`能包含空串``，所以当然能选

所以，`cdadabcc`的目标子串为`adbc`。

实际编码中，为了使算法加快，可以预处理出两个数据结构：

- `suffix`：后缀字母集合。`suffix[i]`是一个`Set`，表示`S[i:]`所拥有的字母集合。用以快速判断某字母后面的子串是否能包含剩余所有字符。
- `ch2Index`：字母到下标的映射。配合二分查找，用以快速获取大于某个下标的最近下标。
