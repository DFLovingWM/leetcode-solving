# 有序矩阵中的第 k 个最小数组和

## 思路

一开始以为是M指针（类似于合并M个有序列表），但后来发现，指针不总是前进的，找到next greater sum还可能需要后退，所以该方法不可行。

### 暴力 + 堆/排序

逐行遍历：假设当前行`A`有x个数字，与下一行`B`的N个数字相加后得到(x * N)个数字，然后从中筛选出最小的K个数字、重复该过程。`A`的初始值就是第一行的N个数字。

时间复杂度：`O(M * KN * log(KN)) <= O(40 * 8000 * log(8000)) = O(400W)`，可行。主要是因为题目限制了`K <= 200`，否则该思路无法通过。

暴力算法并没有利用“单调非递减”的条件。

### BFS + 堆

本质上这是个BFS/DP问题，状态表示为`(C1, C2...Cm, sum)`，其中：

- `C1, C2...Cm`：每一行的当前下标
- `sum`：当前和

由于`1 <= m <= 40`，使用二进制压缩状态，状态空间也很大，所以一般的迭代肯定会炸；然而题目给了另一个限制`1 <= k <= 200`，告诉我们实际上不需要完整的迭代过程，只需要在队列中保存前K个状态即可。

时间复杂度：`O(K * M^2) ~= O(200 * 40^2) = O(32W)`。

### 二分枚举 + 回溯

Top K问题容易联想到二分解法。所有行的第一列之和为`left`、最后一列之和为`right`，那么就在`[left, right]`区间进行二分：每次检测`mid`，设小于等于`mid`的和有`cnt`个，那么如果：

- `cnt >= K`：左边数字过多，说明答案在左边（包括正确答案），所以有`right = mid`
- `cnt < K`：同理有`left = mid + 1`

那么如何求小于等于`mid`的和的个数呢？可以使用回溯算法：从`left`出发，每行的指针不断右移，每右移一次发现如果小于等于`mid`，则个数`cnt++`。注意需要剪枝：当已满足`cnt >= K`时，可以提前结束递归，因为已经可以确定答案在左边。

时间复杂度：因为二分范围为`X = right - left`，然后每次检查中，剪枝保证了最多递归`K`次，所以有`O(KlogX) <= O(200 * log(40 * 5000)) ~= O(3400)`，奈斯。

回溯部分利用了“单调非递减”的条件。