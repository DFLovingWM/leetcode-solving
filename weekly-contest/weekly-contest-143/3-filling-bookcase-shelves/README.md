# 1105. 填充书架

## 思路

属于简单几何题型中的DP。

### Top-down DP

思考过程：

首先，考虑如何表示当前局面。回溯基于思想：对于第`i`本书来说，至多有2种选择：要么放在下一行，要么放在第`i-1`本书右边（如果能放得下）。

- 为了能判断“是否能够放得下”，我们可能需要一个`sumWidth`来表示最后一行已经积累的宽度；为了获取该行的高度，可能需要一个`maxHeight`来表示当前最后一行的最大高度。所以状态有3个变量，时间复杂度就是`O(N*W*H)`，发现`O(10^9)`可能会TLE。
- 数据都是`10^3`级别，那么应该是`O(N^2)`时间复杂度才对。所以想办法降维，我们可以用`wi`表示最后一行的第一本书，这样就能用`sum(wi~i)`代替`sumWidth`、用`max(wi~i)`代替`maxHeight`了。不过如果对于每个`i`都遍历`wi~i`，重复工作太多了，而且时间还是`O(N^3)`。所以，在正式DP之前，可以对所有书本进行预处理，求出两个数组：
  - `maxHeight`：表示区间的最大高度，`maxHeight[i][j]`表示书本`i~j`的最大高度
  - `sumWidth`：表示前缀宽度和，`sumWidth[i]`表示书本`0~i`的宽度和，那么区间`i~j`的宽度和就是`sumWidth[i] - sumWidth[j]`

结论：

- 状态函数/表示：`f(i, wi)`表示当前放置第`i`本书、同时最后一行的第一本书是`wi`，最终能达到的最小高度
- 状态转移：`f(i, wi) => min( f(i+1, i) + Hi, f(i+1, wi) )`
- 边界/初始值：当`i === n`时，为`maxHeight[i] - maxHeight[wi]`
- 目标值：`f(1, 0)`。说明：本来应该从第0本书开始，但第0本书两种决策是一样的，相当于从第1本书开始。

### Bottom-up DP

编码比Top-down DP更简单，但是我没想出来，是参考的刘岳哥的题解[动态规划 Python3](https://leetcode-cn.com/problems/filling-bookcase-shelves/solution/dong-tai-gui-hua-python3-by-smoon1989/)。

- 状态表示：`dp[i]`表示放前`i`本书能达到的最小高度。
- 状态转移：`dp[i] = min( dp[j] + maxHeight(j~i) )`，含义是我们想要把`j~i`作为最后一行（前提是总宽度不超过书架宽度），看哪个最小。所以，这里的`j`是逆序遍历。
- 边界：`dp[0] = 0`。因为求的是最小值，所以其它的初始值都是`Infinity`。
- 目标：`dp[n]`。
