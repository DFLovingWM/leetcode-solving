# 跳跃游戏 V

## 题意

给定数组`arr`与`d`，`arr`中每个位置有不同的高度。从某个位置`x`能跳到`[x - d, x + d]`中“连续”更矮的位置上。问最多能访问多少个下标？

## 思路

粗略地理解是，从一个位置`i`可以跳到比它更低的位置`j`，而`j`是有多种选择的，每一种选择都会影响之后的选择，所以这是个DP问题。

### Top-down DP

- 状态表示：DFS函数`int helper(int i)`表示当前在位置`i`上、最终能访问的最多下标数。
- 状态转移：从`i`出发可以往左、右跳到更低的`j`，遍历并找到最大值即可：`max(1 + helper(j))`。
- 边界：当无法到达下一个位置时，即最多只能再访问当前位置，为1。
- 目标：`max(helper(i))`。

### Bottom-up DP

- 状态表示：`dp[i]`表示到达`i`的最大访问。
- 状态转移：考虑上一个（更高的）位置`j`，根据规则，`j`跟`i`之间的所有位置都要比`j`更低，这是以`j`为基准而不是`i`。因此，不能像Top-down那样从`i`出发找`j`，而是需要提前找到`i`的所有前驱位置`j`。然后，`dp[i] = 1 + max(dp[j])`。
- 边界：`dp[i] = 1`
- 目标：`max(dp[i])`

相比Top-down，Bottom-up需要将所有位置进行排序（按照高度从大到小）。这是因为在状态转移中有：`dp[i] = 1 + max(dp[j])`，即由更高的`j`推导出更低的`i`，这就需要`dp[higher]`比`dp[lower]`先求出来。所以一开始需要将位置排序，以便迭代时从最高位置开始。

### 另一种Bottom-up DP

Bottom-up还有一种思路，状态表示跟Top-down一样，所以代码也差不多，这里就不详述了。
