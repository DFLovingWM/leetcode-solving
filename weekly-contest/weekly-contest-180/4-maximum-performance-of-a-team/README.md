# 最大的团队表现值

## 思路

本题的代码很简单，难点在于如何抽象出思路。

从团队表现值的计算方式入手：`sum(速度) * min(效率)`。要使结果最大化，肯定是要：

- sum尽量大
- 最小效率尽量大

因为min是单个值，所以我们可以遍历它：首先将效率进行降序排序，然后遍历的同时维护一个“团队”，那么当前效率`efficiency[i]`就是最小效率。然后为了找到最大的K个速度（注意，这是个【Top-K问题】），可以使用大小为K的最小堆，存放`i`左边员工的速度。这样时间复杂度就是`O(NlogK)`。

## 拓展思考

我一开始对这个算法有点疑问，在此记录一下：按照维护大小为`K`的最小堆的思路，当遍历到员工`i`时，表示以`efficiency[i]`为最小效率的一个团队，那么如果`speed[i]`最小、被最小堆弹出来了，那么这个团队就不包括`i`了，算出来的结果岂不是错误了？

当`speed[i]`最小而被弹出时，堆中元素的和`sum`与上次（即遍历到`i-1`时）相比没有变化，那么因为`efficiency[i] <= efficiency[i-1]`，所以当前结果`ans[i] = sum * efficiency[i] <= ans[i-1]`，因此算出来的`ans[i]`即使具有错误的意义，但也不会影响最终结果。
