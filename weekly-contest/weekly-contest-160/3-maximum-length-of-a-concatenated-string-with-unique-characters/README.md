# 串联字符串的最大长度

## 思路

首先，考虑数据结构。检测单词A、B连接之后是否会有重复字符，可以使用：

- 哈希表：用HashSet记录每个单词的字符集，这样检测A、B变成检测2个HashSet，只需要O(M)，M为平均长度。
- 位压缩（或者`C++`的`bitset`）：考虑到字符只有小写字母，范围较小，可以使用位压缩，即用一个整数的二进制来存储是否含有某个字母，26位肯定能存下。

其次，考虑算法。

### 回溯

从零构造字符串。对于一个单词来说：

- 如果与已有字符串不冲突，则可以选择：连接、不连接
- 如果冲突，则只能选择：不连接

考虑可行性：栈深为`16`，不会爆栈；叶子结点数为`2^16=65536`，不会超时。该解法可行。

### 动态规划

维护一个`dp`数组（增长），保存可行组合。对于每个单词`A`，在`dp`中寻找与`A`不冲突的组合，将它们结合后加入`dp`中。`dp`中字符数最多的就是答案。有3种方式进行DP：

- 暴力：对于每个单词，在`dp`中搜索与其不冲突的，累加后加入`dp`。最终答案需要寻找`dp`中的最大值。
- 二分查找：维护一个严格递增的`dp`数组。对于每个单词，在`dp`中二分寻找与其不冲突的最右（大）者。如果累加后是递增才加入，否则不加入。最终答案为`dp[n-1]`。
- 递增：维护一个非严格递增的`dp`数组（最大栈）。对于每个单词，在`dp`中逆序查找第一个与其不冲突的。如果累加后是递增的就加入，否则增加前一个。

## 参考

- [lee215: Bruce Force DP](https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/discuss/414172/Python-Bruce-Force-DP)

## 相似题目

- 周赛159，第4题
