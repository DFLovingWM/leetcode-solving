# 380. 常数时间插入、删除和获取随机元素

## 题意

实现以下3种操作，要求时间复杂度为O(1)：

- 增加元素（不能增加重复元素）
- 删除元素
- 获取随机元素，保证每个元素的概率相同

## 思路

O(1)的增加、删除操作，即`HashMap`，这个很简单。难点在于“获取随机元素”，这一步是要通过随机下标来获取值的，要达到O(1)就只有两种数据结构：

- 数组：天然的O(1)随机存取
- HashMap：建立“下标=>值”的映射，就能通过O(1)获取值

而其实这里无论用数组或HashMap，大体思路都是一样的，我们就拿数组来说。然而问题来了，数组的删除操作是O(N)的，怎么才能达到O(1)呢？首先我们想想，为什么在数组中删除一个元素的操作是O(N)复杂度？这里分2种情况讨论：

1. 给定下标，删除目标元素：因为下标确定，所以要删除的元素是唯一的、确定的。删除元素后，因为要将其后的子数组全部向前移动，移动操作就是O(N)时间。
1. 给定值，删除目标元素：因为值可以重复，所以本来要删除的元素并不唯一，但这道题规定了值不能重复，所以元素也是确定的。首先要O(N)时间来定位到目标元素，然后删除后又需要O(N)时间来移动子数组。

这道题的删除API是`remove(val)`，即第2种情况。我们需要用一些技巧，将这2个O(N)操作优化为O(1)：

- 定位元素：通过值来找到下标，可以通过HashMap建立“value => index”的映射。
- 删除元素：为了避免移动子数组，我们可以把要删除的元素与tail元素交换，再进行删除。

综上所述，我们只需要2个对象：

- HashMap
- Array

## 反思总结

数组的删除操作一般是O(N)，但是如果确定下标，可以将要删除的元素交换到tail再删除，这样就能达到O(1)的时间！

这道题由于没有重复元素，通过value确定index的时间能够达到O(1)，如果没有这样的限制呢？（381题）
