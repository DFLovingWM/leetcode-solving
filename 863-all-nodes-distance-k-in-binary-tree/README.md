# 863. 二叉树中所有距离为 K 的结点

## 思路

### 层次遍历

距离为K很容易想到层次遍历（K层），但是二叉树的BFS并不可行。需要一点手段。

- 转图+层次遍历：先将二叉树通过DFS转化为图（邻接表），再用层次遍历（BFS）到第K层即可。细节：化为图时，结点可以简单用数字来表示，因为题目限制规定了每个结点的数字不相同，所以数字就可以代表一个结点。
- 添加父指针+层次遍历：思路与【转图】差不多，对每个结点增加指向父结点的指针（克服了一般树中结点对父结点不可达的问题），然后进行层级遍历。其实添加父结点后，结点之间就是双向边了，也相当于转变为图。

因为使用邻接表，所以时间为O(N + E)。

### 坐标化

对每个结点赋予一个下标（参考二叉堆），通过计算下标之间的距离，来获取对应的结点集。时间为O(NlogN)。

这种解法非常创新，可以这样想：如果树是完全不平衡的，可以想象为数组，那么与`i`相距`K`就是`arr[i + K]`和`arr[i - K]`。而能表达树的层次下标的，很容易就想到二叉堆的下标系统，它遵循一定的运算规律。

### 分治

本题最优秀的解法，将递归的力量发挥得淋漓尽致。

基本思想是：对于结点`target`来说，寻找`K`距离的结点，有2个方向：

- 往下找（子结点方向）：这种情况很简单，只要在递归子结点时将`k`作为【入参】并递减，然后`k`减到0时所在结点就是答案。可以抽象成函数`getFrom(node, k)`。
- 往上找（父结点方向）：这种情况较为复杂，因为一般二叉树没有指针指向父结点，所以要靠回溯来传递参数：将`k`作为【出参】并递减，返回给上一层。这时需要对K小小讨论：
  - `k < 0`时，表示无目标，不作处理
  - `k === 0`时，表示该结点也是答案
  - `k > 0`时，表示对于该结点`node`，要寻找`k`距离的结点，这是一种递归的情况，依照前面的逻辑，往下找`getFrom(node, k)`以及往上照。

具体可以画一个图来辅助理解。另外也许代码更容易被理解。

## 反思总结

重要题目（提升对二叉树递归的理解）！
