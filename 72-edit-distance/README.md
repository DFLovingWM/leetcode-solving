# 72. 编辑距离

## 思路

### BFS（超时）

求最少操作，一开始想到BFS。但是如果用BFS，扩展结点太多，肯定会超时：

- 增加一个字符：(A+1)个位置，26种字符（甚至更多，题目没有说明）
- 删除一个字符：A个位置
- 修改一个字符：A个位置，26种字符

### 动态规划

使用Bottom-up DP，可以参考[ivan_allen的评论](https://leetcode-cn.com/problems/edit-distance/comments/65607)。由以下3个场景来发现状态转移：

> 1、如果从A[:i-1]到B[:j-1]最少需要k步，那么从A[:i]到B[:j]最少需要几步？

解答：走了k步后，看A[i]和B[j]：如果相等，则不需要操作，还是k步；如果不相等，则需要将A[i]修改为B[j]，总共(k+1)步。

> 2、如果从A[:i]到B[:j-1]最少需要k步，那么从A[:i]到B[:j]最少需要几步？

解答：走了k步后，发现还少了一个字符，那么就增加上B[j]这个字符，总共需要(k+1)步。

> 3、如果从A[:i-1]到B[:j]最少需要k步，那么从A[:i]到B[:j]最少需要几步？

解答：走了k步后，发现多了一个字符，那么就删除掉A[i]这个字符，总共需要(k+1)步。

综上所述，设`dp[i][j]`为`A[:i]`变化到`B[:j]`所需的最少步数，则有推导式：

```js
if (A[i] === B[j]) {
  dp[i][j] = dp[i-1][j-1]
} else {
  dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])
}
```

## 反思总结

1. 这道题目的难点在于，如何想到用DP，以及怎么推导出DP状态转移方程。
1. 求最小Xxx。除了BFS，还可以是DP。
