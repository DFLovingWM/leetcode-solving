# 295. 数据流的中位数

## 题意

设计数据结构，寻找数组的中位数，并且数组是增长的。即实现API：

- `addNum(num)`：增加一个元素
- `findMedian()`：寻找数组的中位数

## 思路

要找中位数，就是要找整个数组排好序后、中间的那1个/2个元素。

这里存在一个“懒排序”法，即每次查询都将数组排序，这种查询时间为O(NlogN)的方法就不考虑了。

考虑这2个潜在需求：

1. 维护次序（增加）
1. 随机访问（查询）

然而这两个需求，在数据结构中又是“互斥”的，难以同时高效实现：

- 数组型：可随机访问，但是维护次序需要O(N)
- 链表型：可快速增加，但无法快速地随机访问

### 数组 + 插入排序

维护一个有序数组。当有新元素要插入时，线性地寻找插入位置，同时将子数组后移一位（就是插入排序的操作）。复杂度为：

- 增加：O(N)
- 查询：O(1)

本来想用二分查找的，后来想了下，其实没有必要，因为移动子数组的时间已经达到O(N)了。

### 有序表 + 维护指针

利用语言中已实现的有序表来维护数据流。考虑到可以有重复元素，Java的`TreeSet`无法使用，只能使用C++提供的`multiset`。

但为了让查询时间为O(1)，我们需要使用迭代器跟踪中位数的位置。具体可以看[官方题解](https://leetcode-cn.com/problems/find-median-from-data-stream/solution/shu-ju-liu-de-zhong-wei-shu-by-leetcode/)。复杂度为：

- 增加：O(logN)
- 查询：O(1)

### 堆

Intuition：排序的结果是将每个数字放到正确的位置上，但我们只关心中间那两个数字，即“最值”，可以考虑用堆。

维护2个堆：左边一半用大顶堆L，右边一半用小顶堆R。这样堆顶就是中位数！当增加数据时，为了维护两个堆的大小平衡（具体来说，要么L、R同样多，要么L比R多1），需要将新数据都经过一遍L和R，具体算法为：

- 先插入L，然后L将堆顶插入R
- 如果R比L多，则R将堆顶插入L

这样2个堆就平衡了！时间复杂度：

- 增加：O(logN)
- 查询：O(1)

## 反思总结

好题！

解决“流动的中位数”所用的数据结构。
