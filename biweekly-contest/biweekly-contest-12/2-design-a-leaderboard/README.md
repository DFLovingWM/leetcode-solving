# 1244. 力扣排行榜

## 思路

考虑API所需操作：

- 增加/修改KV值：需要根据`playerId`快速定位元素
- 获取最大的K个值：需要快速获取最大的`K`个`score`

### 哈希表

最容易想到的方案，用Map结构存储`playerId => score`映射，但这样获取前`K`个值时需要排序。时间复杂度：

- 增加：O(1)
- 修改：O(1)
- 获取前K，有几种方案：
  - 快速排序：O(NlogN)
  - 堆排序：O(NlogK)
  - 快速选择：O(N)，因为这是个Top K问题

适合写多读少。

### 哈希表 + 有序表

哈希表解法的缺点是时间复杂度都在读取上面了，为了解决这种情况，需要额外地、反向地对`score`建立有序表，这是个一对多的映射（多个人分数相同的情况），需要类似于`TreeMap<Integer, Integer>`的结构，第二维存重复数目。注意，这种思路仍然需要哈希表建立正向映射，以通过`playerId`直接获取`score`。

在`C++`、`Java`中才有现成的有序表可以用。其实一开始我理解错了题目，以为题目给定的范围`0 <= score <= 100`是分数，但其实是分数的增加。如果分数范围是确定的、并且较小，可以用“索引数组”来作为有序表的代替。

时间复杂度：

- 增加：O(logN)
- 修改：O(logN)
- 获取前K：O(KlogN)

## 反思总结

【索引数组/计数数组】可以视为【有序表】的低配版。
