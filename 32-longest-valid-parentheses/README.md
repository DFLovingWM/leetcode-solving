# 32. 最长有效括号

## 思路

- 暴力法（TLE）：遍历所有子串，用stack判断是否合法。效率较低，因为没有利用子串之间的联系。时间为O(N^3)。
- 动态规划（爆内存）：`dp[i][j]`表示`text[i:j]`是否合法，则状态转移如下。但因为是O(N^2)时间，还是不能AC。
  - 如果`s[i] === '(' && s[j] === ')'`，则取决于`dp[i+1][j-1]`
  - 如果`s[j-1] === '(' && s[j] === ')'`，则取决于`dp[i][j-2]`
  - 如果`s[i] === '(' && s[i+1] === ')'`，则取决于`dp[i+2][j]`
- 动态规划（AC）：`dp[i]`表示`text[:i]`中最长有效括号子串的长度。则状态转移如下。时间为O(N)。
  - 如果以`()`结尾，则`dp[i] = dp[i-2] + 2`
  - 如果以`))`结尾，则`dp[i] = dp[j-1] + dp[i-1] + 2`，其中`j`为`i`的“对称”位置（具体看代码注释）
- 计数法：顺序扫描字符串，记录当前字符串中左右括号的个数；然后再逆序扫描一遍。时间O(N)，空间O(1)。
  - 算法：计数表示的是当前字符串中的括号频次，注意这里的“当前”，起点不一定是头尾。顺序扫描过程中，当`right > left`时，说明当前字符串是不合法的、也无法参与之后的过程，要重新选定起点、重新计数。而当`left === right`时，因为排除了`right > left`的情况，所以此时是`right`的数量刚好追赶上了`left`，说明当前字符串是个合法的括号串，于是更新答案。逆序扫描同理。
