# 146. 最近最少使用

## 题意

设计一个有容量限制的LRU（最近最少使用，即优先删除**访问时间最远**的元素）缓存。要求在O(1)时间内完成两种操作：

- put：增加/修改KV对，并将其置于最优位置（最不可淘汰的）。如果是增加、并且满了的时候，需要先删除最差位置上的KV对。
- get：获取KV对的值，并将其置于最优位置。

## 思路

### 思路1

第1步，让我们重新思考这两个API背后包含的CRUD操作：

我们可以设想一个队列，最左边/头部是最差位置（首当其冲），最右边/尾部是最优位置（最不可能淘汰）：

put操作有啥：

- 删除head元素
- 增加新元素到尾部
- 移动元素，这里其实是2个操作的结合：
  - 删除某个（任意）位置上的元素
  - 增加新元素到尾部

get操作呢？

- 获取值
- 移动元素

综上，我们实际上要实现：

- put
  - 删除任意位置元素
  - 增加新元素到尾部
- get
  - 获取值

第2步，选取数据结构：

首先：

- 获取值：O(1)访问，即`HashMap`。但是<u>`HashMap`（指与Java上的HashMap等价的任意语言的哈希表）并没有维护插入/访问顺序</u>，所以是不足够的。
- 删除任意元素：
  - 数组：删除任意元素，要移动后续子数组，需要O(N)时间。
  - 单链表：删除任意元素之前，要把头指针移动到目标元素之前的结点，也需要O(N)时间。不过这里可以优化：`HashMap`以key映射到目标结点之前的结点。这样我们就可以在O(1)时间获取到目标结点之前的结点。但是这样还是不行，因为目标结点之前的结点可能会被删掉，这样就维护不了。
  - 双向链表：到了这里，答案就呼之欲出了。如果将单链表换成双向链表，同时用`HashMap`以key映射到目标结点本身。这样一来删除的时候，我们就能直接获取到目标结点、以及它的`prev`、`next`结点。

综上，使用的数据结构为：HashMap + DoublyLinkedList，具体实现没有什么好说，只是双向链表实现时，头尾有dummy结点会更让代码简便。

另外，有人指出其实这就是Java的`LinkedHashMap`的内部实现，所以这道题也可以仅仅用它来实现。

### 思路2

做完后发现实际时间有点慢，于是看了下JavaScript版本最快的答案，发现……只是用了一个`HashMap`就搞定了，exo me？

研究了一番才知道，原来自己对JS的`Map`认识还不够深，上面有下划线那句话说的是不准确的。<u>Map的key并不是完全“无序”的，它在遍历的时候（`keys`、`values`、`entries`、`for...of`）会依照**插入**顺序，换句话说，**插入新key**会在末尾，而**修改key**或**访问key**时并不会改变key的次序。</u>

既然Map维护了插入顺序，那我们只需要额外维护“修改”、“访问”这2种操作时的key次序就行了。而方法就是用“插入”来代替这2种操作：

- 修改：删除key、插入[key,newValue]
- 访问：删除key、插入[key,oldValue]

大功告成，如沐春风。
