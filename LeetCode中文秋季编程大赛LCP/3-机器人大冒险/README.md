# 3. 机器人大冒险

## 题意

在二维坐标平面上，机器人从原点开始，会重复地根据命令`commands`走。问机器人是否能够安全到达终点。

## 思路

机器人能成功，有2个充要条件：

- 终点在它的路径上
- 所有障碍都不在它的路径上

首先考虑暴力法，即模拟机器人行走路径，直到终点。时间为O(x + y)，由于数量级为`1e9`，所以肯定TLE。

然后想到<u>坐标转换</u>。因为机器人会一轮又一轮地执行`commands`这个命令数组，所以对于那些很远的坐标，只需要将它转换到一轮以内，再进行判断。所谓的一轮坐标内，举个例子：

> RUU

那么机器人一轮的路径为：(0, 0), (0, 1), (1, 1), (2, 1)，即其活动范围在(0, 0) ~ (2, 1)这个矩形内。然后假如终点坐标为：(100, 100)，那么将该终点缩小N个矩形后得到坐标：(0, 50)，具体计算方式为：

```plain
100 - 2 * 50倍 = 0
100 - 1 * 50倍 = 50
```

“50倍”是怎么算的：

```plain
Math.min(100 / 2, 100 / 1) = 50
```

对于障碍也一样，需要注意只需要判断小于终点坐标的障碍。

另外，关于哈希：将类似于”二维坐标“这种多个元素进行哈希时（相当于多对一映射），为了保证唯一，有多种思路：

- 哈希为数字：需要注意题目给出的数字范围，防止冲突。因为`10^9`约为`2^30`，所以为了保证(x, y)的哈希唯一，可以这样：

```js
function getHashKey (x, y) {
  return (x << 30) | y
}
```

- 哈希为字符串：更简单，很容易就构造出唯一

```js
function getHashKey (x, y) {
  return `(${x}, ${y})`
}
```

- Python可以直接用元组（基本类型）

```python
def getHashKey(x, y):
  return (x, y)
```
