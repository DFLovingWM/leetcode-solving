/**
 * 前缀积通过对数变为前缀和问题
 */
function numSubarrayProductLessThanK (nums, K) {
  if (K === 0) return 0 // 因为不能对0取对数，所以作为特殊情况：正整数乘积绝对大于0

  K = Math.log2(K)
  let sum = 0
  let count = 0
  const prefix = [sum]
  for (const num of nums) {
    sum += Math.log2(num)
    const pos = bisectRight(prefix, 0, prefix.length, sum - K + 1e-8)
    count += prefix.length - pos
    prefix.push(sum)
  }

  return count
}

function bisectRight (arr, left, right, target) {
  while (left < right) {
    let middle = left + Math.floor((right - left) / 2)
    if (target >= arr[middle]) {
      left = middle + 1
    } else {
      right = middle
    }
  }
  return left
}

[
  [[10,5,2,6], 100],
  [[4,32,23,1,11,21,8,3,12,21,33,5,14,11,9,14,4,27,5,7,7,14,13,9,17,10,3,4,17,31,7,19,4,7,20,5,4,3,24,30,9,11,23,16,7,21,23,22,12,20,8,20,18,11,5,8,21,5,11,31,28,21,13,21,22,3,2,1,32,8,8,27,4,26,13,14,4,15,6,10,28,15,18,20,29,1,1,12,5,18,10,9,5,13,1,2,7,3,23,26,3,4,13,9,32,32,31,26,19,8,7,29,16,21,28,14,18,5,25,3,4,33,27,3,10,10,22,13,13,32,18,11,27,12,3,33,21,3,5,23,12,23,23,20,24,31,26,7,25,1,5,28,1,1,29,7,31,20,21,32,23,24,13,21,14,30,8,5,23,26,31,31,25,33,17,30,20,20,16,16,2,8,10,5,10,16,27,8,25,5,3,22,21,30,25,20,4,10,9,4,3,20,14,13,4,3,3,1,32,29,13,25,13,28,10,26,17,29,13,28,20,22,6,6,2,30,15,2,29,21,10,28,33,22,6,25,8,18,29,17,1,25,17,27,27,28,16,18,3,4,5,28,20,32,11,23,1,33,12,7,29,32,6,33,15,33,24,13,32,15,24,20,11,27,20,7,2,21,6,11,16,27,24,22,7,4,15,16,1,25,22,16,4,9,19,16,10,14,9,30,18,17,6,8,9,23,1,9,22,20,5,1,15,30,23,3,8,10,9,22,24,9,24,9,5,20,27,16,22,7,6,11,22,27,31,16,30,8,14,12,9,2,29,33,13,18,14,30,20,19,16,33,8,31,31,30,6,15,6,2,30,15,32,17,33,14,22,2,4,23,22,21,29,8], 9931],
  [[1,1,1], 1],
  [[1,2,10],10],
].forEach(input => {
  console.log(numSubarrayProductLessThanK(...input))
})

/**
 *   5 10 9
 * 1 5 50 500  K=100
 * 
 * answer = 4
 * [5]
 * [10]、[5,10]
 * [9]、[10,9]
 */