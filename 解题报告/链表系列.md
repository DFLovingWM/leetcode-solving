# 链表系列

## 数据结构：链表结点

单链表结点的定义：

```js
/**
 * @param {any} val 值
 * @param {ListNode} 下一个结点
 */
function ListNode (val, next = null) {
  this.val = val
  this.next = next
}
```

与数组相比，链表结点的特点有：

- “去中心化”（不存在一个能立即访问到任意一个结点的中心）
- 类似于递归的“自驱动”结构

## 解题思路

- 迭代：适合顺序处理。
- 递归：适合逆序处理。因为定位到`tail`需要`O(N)`时间，如果用迭代的话则需要多次定位、很费时。递归法很多时候又能衍生出栈解法。
  - 前序遍历
  - 后序遍历

## 处理技巧

### Dummy结点

在许多场景中，引入dummy结点会极大地简化我们的代码，不需要进行特殊判断。它的作用有点类似于“Bottom-up DP中将数组长度多开1位”。比如：

- 空链表增加第一个结点时，不需要特殊处理
- 链表删除唯一的结点时，不需要特殊处理
- ……

所以一般在创建一个新链表时，第一个结点就是dummy结点，它的下一个结点才是`head`。

### 新链表沿用旧结点

`JavaScript`不像`C++`那样存在“引用”，当题目需要“返回一个新链表”时，函数需要设计成具有返回值：

```js
/**
 * @param {ListNode} head 原链表头
 * @returns {ListNode} 新链表头
 */
function solve (head) {
  // ...
}
```

很多时候，新链表往往不需要创建多个结点，而是对已有链表的结点进行重新串联。举个例子，在链表的归并排序中，有一步是合并两个有序链表，除了dummy结点是通过`new`创建的，其它结点都不需要`new`，而是沿用有序链表中的结点。

## 经典题目

- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)，多种解法，对链表的递归建立认知
