# LeetCode题目分类

分类的根据：

- 题型（挖掘通用套路）
  - Xxx问题
- 解法（针对性的专题训练）
  - 数据结构
  - 算法

## 未分类

Lowest Common Ancestor: 235, 236

## K-Sum问题

K个数之和为sum的问题。其中，K是确定的（不一定是连续的K个数）。

通用解法：

1. 排序
1. 回溯 + 剪枝
1. 叶子结点为2-Sum问题：双指针/Hash

时间复杂度：O(N ^ (K - 1))

题目：

- [1. 两数之和(K=2)](https://leetcode-cn.com/problems/two-sum/)
- [15. 三数之和(K=3)](https://leetcode-cn.com/problems/3sum/)
- [18. 四数之和](https://leetcode-cn.com/problems/4sum/)
- [216. 组合总和3(其实是K-sum问题)](https://leetcode-cn.com/problems/combination-sum-iii/submissions/)
- [259. 三数之和小于K](https://leetcode-cn.com/problems/3sum-smaller/)

## 子数组问题

问法：

子数组的【和/积】【等于/大于/小于】K的【个数/是否存在/最长长度/最短长度】

思路：

- 前缀和，形式有：
  - 哈希（Map/Set）：适用于等值搜索，O(N)时间
  - 二分查找（数组）：适用于单调数组的范围搜索。复杂度为O(NlogN)。当不单调的时候，就用不上了（862）。
- 滑动窗口：适用于范围搜索，O(N)

题目：

- [560. 和为K的子数组，求个数](https://leetcode-cn.com/problems/subarray-sum-equals-k/)
- [437. Path Sum III](https://leetcode.com/problems/path-sum-iii/)
- [325. 和为K的子数组，求最长长度](https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k/)
- [523. 和为nK的连续子数组，求是否存在](https://leetcode-cn.com/problems/continuous-subarray-sum/submissions/)
- [713. 积小于K的子数组，求个数](https://leetcode-cn.com/problems/subarray-product-less-than-k/)
- [209. 和大于等于K的子数组，求最小长度](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

## 判断重复元素问题

- 217
- 219
- 220

## 数组删除元素问题

- [27. 删除目标元素](https://leetcode-cn.com/problems/remove-element/)
- [26. 删除重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)
- [80. 减少重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

## Top K问题

如果没有给定有利条件（比如数组是有序的），那么思路有：

- 排序：最直接的方法，时间O(NlogN)。在一定条件下（类似于“频次”的题目），可以使用“索引排序”来达到`O(N)`时间
- 堆：通常维护大小为K的堆来将时间复杂度降低到`O(NlogK)`。这里通过分析K的大小，做一些时空优化：
  - K比较小 => 维护大小为`K`的最差堆：每次遍历，新元素跟堆顶（最差）元素进行比较，挑选更好的；最终剩余的`K`个就是最好的。
  - K比较大 => 维护大小为`N-K`的最好堆：每次遍历，新元素跟堆顶（最好）元素进行比较，然后挑选更差的；最终剩余的`N-K`个就是最差的，用全集减去这些，就是`K`个最好的。

不过通常要利用题目中的有利条件，比如有序数组、二叉搜索树等等，就能有更快的算法。

题目：

- [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)
- [451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)
- [692. 前K个高频单词，字典序升序输出](https://leetcode-cn.com/problems/top-k-frequent-words/)

## 第K个数字问题（狭义的Top K）

如果堆解法TLE/MLE了，就尝试二分解法。这属于隐晦而高级的二分查找。

1、题型特点：

第K个数字的问题，则是在Top K基础上加了些限制条件：

- 第K个：不要求前K个，只需要在某种规则（比如最小）下的第K个
- 数字：元素有二向性规则，一般是数字（比如大小）

2、思路：

> 找出第K小的数字

“第K小的元素”意味着“比该元素小的数字有K个”，所以，每次选出中间点M后，数一下列表中【小于等于M】的数量C，进行二路归并（注意不能是三路，即二分过程一定要收敛到空）：

```js
if (C < K) {
  L = M + 1 // 左闭。表示这里表示M不可能，反推条件不包括相等
} else {
  R = M // 右开。这里也可以反推条件是包括相等情况的
}
```

3、题目：

- [378. 有序矩阵中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)
- [719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)

## 二分查找

进阶题型：

- [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/)
- [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)
- [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
- [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)
- [81. 搜索旋转排序数组2（有重复元素）](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/submissions/)

## 【滑动窗口】解决【子串问题】

- 适用条件：寻找子串问题，并且“扩展”和“缩减”在满足条件时只能选择其一。
- 细节
  - 滑动窗口：遍历出子串，右指针探索、左指针优化，O(N)。
  - HashMap：用以统计字符，因为支持O(1)的增删操作，与滑动窗口的遍历方式配合得很好。一般需要设置一个变量来代替HashMap的遍历，将该过程从O(N)优化到O(1)。
- 时间：一般为O(N)，如果不是则想方设法优化为O(N)
- 题目
  - 76（模板题）
  - 3、438、159
  - 424、1004

## 回溯算法

Backtrack专指“状态空间搜索”问题中的DFS解法。LeetCode上已经有人整理了[backtrack通用解法的思路以及使用场景](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))。

求所有可能性（不是数量），只能用回溯算法来穷举。

编程细节：

- 处理答案的方式
  - 前序：设一个全局变量`res`存放答案，将潜在答案`acc`放在递归函数的入参处（常用）
  - 后序：将潜在答案`acc`作为递归函数的出参返回，然后由上层整合答案`res`（难理解但更秀）
- 如果候选答案`acc`是引用类型（比如数组），则需要在某个时机将它拷贝：
  - 递归时传一个copy
  - 加入结果集时再copy，则递归后需要手动回溯

题目：

- [78. 序列(无重复元素)的子集](https://leetcode-cn.com/problems/subsets/solution/hui-su-suan-fa-by-powcai-5/)
- [90. 序列(有重复元素)的子集](https://leetcode-cn.com/problems/subsets-ii/submissions/)
- [46. 序列(无重复元素)的全排列](https://leetcode-cn.com/problems/permutations/)
- [47. 序列(有重复元素)全排列](https://leetcode-cn.com/problems/permutations-ii/)
- [31. 下一个排列(C++ API)](https://leetcode-cn.com/problems/next-permutation/)
- [556. 下一个更大元素(排列)](https://leetcode-cn.com/problems/next-greater-element-iii/)

- [39. 组合总和(无限)](https://leetcode-cn.com/problems/combination-sum/)
- [40. 组合总和(有限)](https://leetcode-cn.com/problems/combination-sum-ii/)

## 背包问题（Knapsack）

- 01背包
  - [474. 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)
  - 周赛159，第4题
  - 周赛160，第3题
- 完全背包
  - [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)，求排列方案数
  - [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)，求排列方案数
  - [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)，求组合方案数
  - [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)，求最短方案的长度
- 多重背包

## 位压缩（常见于动态规划中）

位压缩常见于动态规划、回溯中：

- 周赛160，第3题
- 周赛162，第4题：枚举所有策略

## 区间问题（套路很重要）

思路：排序。具体是按照start还是end，取决于问题场景。

- [56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/submissions/)

## 【单调栈】解决【Next Greater问题】

题目：

- [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/submissions/)
- [1019. 链表中的 NextGreater](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/comments/)
- [496. 数组中的 NextGreater](https://leetcode-cn.com/problems/next-greater-element-i/)
- [503. 循环数组中的 NextGreater](https://leetcode-cn.com/problems/next-greater-element-ii/)

## 最长Xxx串问题

- 最长公共子串LCS
- 最长公共子序列LCS
- 最长回文子串LPS
- 最长回文子序列LPS

## 反转链表系列

反转链表分为【循环】和【迭代】两种解法，几个题目的思路都是类似的。

- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)
- [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)
- [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

## 悬而未决（个人）

- [118. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)
  - 朴素解法虽然比较慢，但有扩展性(3段 => K段)
- [336：Palindrome Pairs](https://leetcode.com/problems/palindrome-pairs/discuss/79195/O(n-*-k2)-java-solution-with-Trie-structure)，Trie解法。
- [1008](https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/discuss/252232/JavaC++Python-O(N))：存在O(HlogN)乃至O(N)解法？时间复杂度分析是否错了？

## 全局搜索标签

- 重要题目
- 入门题/基础题/模板题
- 变形题
- 好题
