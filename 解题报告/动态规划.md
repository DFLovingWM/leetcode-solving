# 动态规划

## 定义

用于寻找多策略下的最优解：

- 当前局面是由上一个选择造成的，并且当下选择也会影响之后的局面与选择。
- 局部最优不一定导致全局最优。在未知最终最优结果的情况下，需要求解所有的子问题。

## 类比

计算机的能力之一在于穷举，算法层次为：

- 回溯：需要求出所有的策略。复杂度为`O(N!)`级。
- 动态规划：只需要求出所有策略下的最值，并且状态可复用。复杂度为多项式级别。
- 贪心：全局最优取决于局部最优。复杂度为线性级别。

## 分类

动态规划又可以细分为：

- Top-down（递归 + 记忆化）：`curr ==> next`
  - 更好理解，通常先思考出来。
  - 思考点：回溯算法、状态转移、递归终止条件。
  - 缺点：虽然复杂度一样，但系统栈花销导致它通常比Bottom-up慢一点。并且当n较大时，栈溢出。
- Bottom-up（迭代）：`curr <== prev`
  - 通常是后想出来，作为对Top-down的进一步优化（时效、空间压缩）。空间压缩方式：滚动数组/逆序更新。
  - 思考点：初始条件（对应Top-down中的递归终止条件）、状态转移方程，以及迭代的方向。与Top-down是反过来的。
  - 缺点：时效通常较好，但是当有效子问题较少时会比Top-down还慢，因为Top-down只会选择合法策略，但Bottom-up会计算所有（下标有效的）子问题，不管它是否有效。
  - 通常用数组表示状态，所以下标不能为负数。遇到需要用负数表示的状态，可能需要用到哈希表之类的结构。

特别情况：当第`i`行仅由第`i-1`行推导而来时，我们可以使用滚动数组省去一维，这样便衍生出一种类似于BFS/层次遍历的解法，然而方向由`curr <== prev`变为`curr ==> next`，姑且叫做“层次推导”法吧，下面题型中有涉及到。

## 解题步骤

1. 思考回溯法（偏朴素算法）的大致思路，然而TLE。
1. Top-down DP：发现子问题可以用基本类型的变量表示出来、并且有重叠，于是用多维数组/哈希表来缓存子问题的结果，变成记忆化搜索。能够AC，但实际时效往往不是太好。
1. Bottom-up DP：优化时间与空间，沿用Top-down的状态转移，设计dp数组、确定初始状态、确认循环方式。

## 常用技巧

- 位压缩
  - 枚举策略
  - 状态的一种哈希（变成“可表示的”）
- 离散化：缩小下标范围

## 题型

背包问题：略。详见于《AcWing-solving》题解。

层次推导：

- [1220. 统计元音字母序列的数目](https://leetcode-cn.com/problems/count-vowels-permutation/)
- [5265. 可被三整除的最大和](https://leetcode-cn.com/problems/greatest-sum-divisible-by-three/)

难题：

- [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)
