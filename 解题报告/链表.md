# 链表系列

## 数据结构：链表结点

单链表结点的定义：

```js
/**
 * @param {any} val 值
 * @param {ListNode} 下一个结点
 */
function ListNode (val, next = null) {
  this.val = val
  this.next = next
}
```

与数组相比，链表结点的特点有：

- “去中心化”（不存在一个能立即访问到任意一个结点的中心）
- 类似于递归的“自驱动”结构

## 解题思路

纯链表题主要考察数据结构，即对链表的结构、递归的形式等进行考察。考算法的很少，一般可以归为其它专题，比如“检查链表环”。

- 迭代：适合顺序处理。
- 递归：适合逆序处理。因为定位到`tail`需要`O(N)`时间，如果用迭代的话则需要多次定位、很费时。递归法很多时候又能衍生出栈解法。
  - 前序遍历
  - 后序遍历

## 处理技巧

### Dummy结点

在许多场景中，引入dummy结点会极大地简化我们的代码，不需要进行特殊判断。它的作用有点类似于“Bottom-up DP中将数组长度多开1位”。比如：

- 空链表增加第一个结点时，不需要特殊处理
- 链表删除唯一的结点时，不需要特殊处理
- ……

所以一般在创建一个新链表时，第一个结点就是dummy结点，它的下一个结点才是`head`。

### 沿用旧结点

`JavaScript`不像`C++`那样存在“引用”，当题目需要“返回一个新链表”时，函数需要设计成具有返回值：

```js
/**
 * @param {ListNode} head 原链表头
 * @returns {ListNode} 新链表头
 */
function solve (head) {
  // ...
}
```

新链表虽然是“新”的，但往往不需要创建N个结点，而是对已有链表的结点进行重新串联。比如在链表的归并排序中，有一步是合并两个有序链表，个中除了dummy结点是通过`new`创建的，其它结点都不需要`new`，而是沿用有序链表中的结点。重新串联法需要注意一点：<u>串联之后最好马上将新结点的所有指向重置（置为`null`），否则很可能因为指向旧链表而产生环。</u>

总的来说，虽然是“返回新链表”，但它实际上跟“原地修改”有着相同的空间复杂度；然而角度还是不同的：前者从结果出发，后者忠实于过程，因此很多时候会产生两种不同的思路、解法。

## 经典题目

- [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)，多种解法，对链表的递归建立认知
