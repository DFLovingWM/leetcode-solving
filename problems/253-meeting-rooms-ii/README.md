# 253. 会议室 II

## 题意

给定若干会议区间，问为了避免冲突，至少需要多少间会议室。

## 思路

需要的会议室数量，就是某个时间点上冲突最多的会议数量。

从简单情况着手：假设有2个会议A、B：

- 如果A、B不相交（比如A在前、B在后），则1个会议室足够了。因为A开完之后，B可以重用该会议室。
- 如果A、B相交，那么需要2个会议室。因为A还没开完，B就要开始，不能用同一个。

很容易想到思路：构建一个数轴，上面的点表示一个个“时间节点”。对于一个时间段[from, to]来说，from点需要1个会议室，则加1；to点释放1个会议室，则减1。一次遍历（模拟时间的流动）下来，累加的最大值就是至少所需的会议数。

核心思路明白就行了。接下来讨论实现细节：怎么表示这个数轴呢？

- 数组的快速排序
  - 算法过程
    - 遍历所有会议，每个会议需要新增2个节点。节点结构包含2个信息：时间点、delta值（+1还是-1）。
    - 对所有节点进行快排，排序依据依次为：（1）时间点在前优先；（2）时间相同时，-1比+1优先（因为要尽可能省会议室，所以在同一个时间点上，先释放会议室，再考虑使用会议室）。
    - 扫描一遍、累计delta，取最大值。
  - 时间复杂度：O(NlogN)，主要在于排序
- 数组的索引排序
  - 算法过程
    - 先找出所有会议中的最大的时间点M，然后建立数组。注意，该数组相当于“时间数轴”，数组下标就表示“时间点”，数组值就是delta值。
    - 遍历所有会议，每个会议需要新增/修改delta值。
    - 扫描一遍、累计delta，取最大值。
  - 时间复杂度：O(M)，M为最大时间点。注意M可能很大，所以该方法的实际耗时可能很慢。
- 有序表（利用Java中的TreeMap）
  - 概述：有序表相当于索引排序的空间优化版本：后者作为连续的空间，在M较大、N较小时，是一个稀疏数组，很多“时间节点”都没有用上；前者所使用的所有空间都是有用的。
  - 时间复杂度：O(NlogN)，因为有序表的CRUD都需要logN时间，一共N个树结点。
