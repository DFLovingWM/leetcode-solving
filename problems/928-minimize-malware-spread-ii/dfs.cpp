/**
 * 删除某个危险结点 + 数最终安全结点
 * 
 * 时间：`O(NM)`, 140ms
 */

#include <vector>
#include <unordered_set>
using namespace std;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initials) {
        initialSet.insert(initials.begin(), initials.end());
        n = graph.size();

        // 邻接表
        adj.resize(n);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i != j && graph[i][j] == 1) {
                    adj[i].push_back(j);
                }
            }
        }

        int maxNode, maxCount = -1;
        for (int node : initials) {
            int count = exclude(node);
            if (count > maxCount || (count == maxCount && node < maxNode)) {
                maxNode = node;
                maxCount = count;
            }
        }
        return maxNode;
    }

    // 返回值：排除了initial后的最终安全的结点数
    int exclude(int initial) {
        unordered_set<int> visited = { initial }; // 标记为已遍历，相当于将该结点删除
        int res = 0;
        for (int i = 0; i < n; ++i) {
            res += max(dfs(i, visited), 0);
        }
        return res;
    }

    // 数连通分量的最终安全的结点数
    int dfs(int i, unordered_set<int> &visited) {
        if (visited.count(i)) return 0;

        // 本结点
        int res = initialSet.count(i) ? -n : 1;
        visited.insert(i);

        // 扩展子结点
        for (int j : adj[i]) {
            res += dfs(j, visited);
        }

        return res;
    }

private:
    int n;
    vector<vector<int>> adj;
    unordered_set<int> initialSet;
};