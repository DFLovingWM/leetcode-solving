# 928. 尽量减少恶意软件的传播 II

## 题意

给定邻接矩阵`graph`和初始危险结点`initial`，返回一个待删除结点（该结点和相关的边都删除），使得最终的安全结点数最多。

## 思路

### 思路1：枚举删除危险结点

首先，肯定要在`initial`中挑一个结点来删除，因为不可能删除安全结点。其次，每选择一个危险结点来删除，在剩余图中数最终安全结点的个数，那么最终安全结点数最多所对应的危险结点就是答案。其中：

- 数最终安全结点个数，本质上是对每个连通分量进行搜索（DFS/BFS）。需要注意，一旦检测到连通分量中存在危险结点，那么整个连通分量的安全结点数就是0。
- 在图中删除一个结点，也可以很简单，相当于把该结点提前标记为“已遍历”。

设`N == graph.size, M == initial.size`，因为需要`M`次搜索，每次搜索花费`O(N)`，所以时间复杂度为`O(NM)`。

### 思路2：找关键危险结点

因为最多只能删除一个危险结点，所以如果有多于1个危险结点能通往安全结点`i`，那么无论删除哪一个，`i`最终还是会被感染。我们的目标是需要尽量多地将“待感染”结点转化为“最终安全”结点，所以需要关注那些仅由1个危险结点连通的结点，然后反过来统计危险结点的“分数”（连通的安全结点数）。分数最高的危险结点，就是需要删除的结点。

时间复杂度：`O(NM)`，因为需要从`M`个危险结点出发搜索，每次搜索需要花费`O(N)`。
