/**
 * 找到“关键”的危险结点
 * 
 * 时间：`O(NM)`, 180ms
 */

#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <algorithm>
using namespace std;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& dangers) {
        const int n = graph.size();
        dangerSet.insert(dangers.begin(), dangers.end());

        // 构造邻接表
        adj.resize(n);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i != j && graph[i][j]) {
                    adj[i].push_back(j);
                }
            }
        }

        // 构造映射：安全结点 => 危险结点
        for (int initial : dangers) { // 从危险结点出发，获取所有它能感染的结点
            unordered_set<int> visit;
            visit.insert(initial);
            dfs(initial, initial, visit);
        }

        // 记录危险结点的分数
        unordered_map<int, int> scores;
        for (auto p : safe2Dangers) {
            auto dangers = p.second;
            if (dangers.size() == 1) { // 如果只被1个危险结点感染
                ++scores[dangers[0]];
            }
        }

        // 挑选答案
        sort(dangers.begin(), dangers.end());
        int maxNode = dangers[0]; // 默认删除下标最小的危险结点
        int maxScore = -1;
        for (auto p : scores) {
            int node = p.first;
            int score = p.second;
            if (score > maxScore || (score == maxScore && node < maxNode)) {
                maxNode = node;
                maxScore = score;
            }
        }
        return maxNode;
    }

    // 从危险结点出发延伸（采集安全结点）
    void dfs(int initial, int i, unordered_set<int> &visit) {
        for (int j : adj[i]) {
            if (!visit.count(j) && !dangerSet.count(j)) {
                safe2Dangers[j].push_back(initial);
                visit.insert(j);
                dfs(initial, j, visit);
            }
        }
    }

private:
    vector<vector<int>> adj;
    unordered_map<int, vector<int>> safe2Dangers;
    unordered_set<int> dangerSet;
};