# 392. 判断子序列

## 题意

判断`S`是否是`T`的子序列。

## 思路

- 快慢双指针(贪心)：用指针`j`遍历`S`、`i`遍历`T`。当匹配`T[i] === S[j]`时，(继续)从`i+1`这个位置开始找`S[j+1]`，以此类推，看最终是否匹配完整个`S`。
  - 时间：O(N + M)
- 二分查找：遍历`T`并构建字符到下标列表的映射。因为下标列表是升序的，所以“从某个位置找字符”时可以用二分查找。
  - 时间：O(N + MlogN)。思路很不错，然而构建映射需要遍历整个`T`，有些得不偿失。
- 动态规划：类似于最长公共子序列的求法，不过DP的值用`boolean`表示就够了。
  - 时间：O(MN)

关于follup-up：如果有`K`个`S`，而`T`只有1个。那么3种方法的时间分别为：

- 双指针：O(KN + KM) ~= O(KN)
- 二分：O(N + KMlogN) ~= O(N + K)
- DP：O(KNM)

因为`K`、`N`很大，`M`相对较小，所以二分法最高效。

## 反思总结

类比解法：

- 判断子串：KMP
- 判断子序列：贪心
