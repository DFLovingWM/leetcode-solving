# 30. 串联所有单词的子串

# 思路

假设：

- N: `s`长度
- L: 每个单词的长度
- K: 单词数量

那么子串的长度为`M = L * K`且有`M <= N`

## 暴力 + Map求单词频次

- 暴力遍历出`s`的所有子串
  - 对于每个子串，检查子串跟`words`是否完全匹配：因为单词的拼接顺序是随意的，所以可以用Map求单词的频次（注意，不是字符的频次），然后看两者是否相等

时间复杂度：O(N * M)

## Map + 以单词为基础的滑动窗口

暴力思路的缺点在于，每次前进一个字符，那么子串之间并没有产生任何关联，频次Map无法「复用」，需要重新求。

而如果寻找下一个子串时，前进`L`个字符的话，那么频次是可以复用的，因为相对于当前子串来说，就是减去最左单词、并加上最右的右边的新单词。

把能复用的一群子串称为「一组」，那么一共有`L`组。循环这`L`组就好了。

时间复杂度：O(L * (N/L)) ~= O(N)。不过这个复杂度不够准确，因为这里没考虑单词的长度、操作代价。

如果能快速判断两个Map相等，那么算法的时间还能再降低一些，参考：https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-6/

# 感想

本质上是一次滑动窗口的高级用法，都知道以「字符」为基础，而这次是以「单词」为基础。同时，滑动窗口往往需要与Map配合，所以本题也考察了Map的用法。
