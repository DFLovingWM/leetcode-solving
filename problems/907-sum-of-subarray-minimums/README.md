# 907. 子数组的最小值之和

## 思路

朴素算法：求出所有子数组，再对每个子数组求min进行累加。时间：`O(N^2)`，会TLE。

对于每个数字`A[i]`，考虑以`A[i]`为min的子数组的个数`n[i]`。为了求`n[i]`，我们可以从`A[i]`向两边出发：

- 向左边出发，遇到第一个比`A[i]`更小的元素(NextSmaller)就停下来，记其下标为`L`
- 同理向右边出发，有`R`

那么对于开区间`(L, R)`中的所有子数组，只要它包含`A[i]`，那么它的最小值肯定是`A[i]`，因为这个区间中没有比`A[i]`更小的数，并且有`n[i] = (i - L) * (R - i)`。所以，我们可以事先对每一个元素，求出左、右两边的NextSmaller，常规做法是使用单调栈。这样总时间优化到`O(N)`。

PS.当存在重复元素时，比如`[1,1,1]`，那么为了避免重复，需要保证左右两个单调栈中有1个非严格递减、1个严格递减。
