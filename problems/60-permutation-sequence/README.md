# 60. 排列序列

题意其实就是：求第K个全排列。最经典的「Top K」问题。

## 回溯

细分又有两种不同的回溯思路：

1. 随意/胡乱/暴力回溯，然后排序后取第K个/用堆：最低为O(N! * log(K))
2. 有序回溯，到第K个就停止：O(K)

当然用方式2啊！为了保证「有序地回溯」，每一位上，都得从1～9的顺序遍历着放。

## 数学

用到的数学知识很简单，就是：N个数的排列数为`N!`。

想法是从高到低逐渐构造出答案。思路是想象这样一棵树，从根到叶子结点，每一层确定一个数字，那么到达叶子结点时，就是想要的答案。

举个例子，当`N=3, K=3`时：

- 第1位：可以放1、2、3。首先想，1所在子树的结点总数有多少？因为如果选了1，那后面只剩下2和3，这两个数字的排列数为`2! = 2`；同理，对于2、3所在子树，排列数都是`2`。既然`K=3`，那么答案肯定走的是2所在的子树。答案更新为`ans = 2`。
- 第2位：剩下1、3两个子树，并且排列数都为1，所以走1。答案更新为`ans = 21`。
- 第3位：剩下3这1个子树，排列数为0，只能走这个。答案更新为`ans = 213`。

个人觉得更好的理解方式是，要求第K个排列，那么答案前面就有`K-1`个排列数。然后永远走「前面累计排列数count」满足`count <= K - 1< count + d`的路径。

整体算法可以用循环实现，而不需要用到递归。

另外，`N!`这个可以提前求出来，其实就是个「前缀积」数组。
