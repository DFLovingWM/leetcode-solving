# 132. 分割回文串 II

## 思路

与版本1的区别是，版本1要求所有切割组合（考察回溯），而版本2求的是最小切割数（很明显就是考虑DP）。于是思路有：

- Top-down：考虑每次切掉左边一部分，递归函数`f(i)`表示将`S[i:]`切开的最少步数。则当`S[i:j]`为回文，即可以切时，`f(i) = min(1 + f(j))`。
- Bottom-up：逆向思维，Top-down是“从左边切”，那这里的场景可以是“从右边补”：`dp[i]`表示`S[:i]`包含的最少回文子串数。状态转移：当`S[j:i]`是回文时可以补上`S[:j]`而变成`S[:i]`，所以有`dp[i] = min(dp[j] + 1)`。

动态规划已经需要O(N^2)时间。这里判断回文有两种子思路：

- 每次都直接判断：花费O(N)，则总共为O(N^3)，可能会TLE。
- 预处理：提前求出所有子串是否回文，这样判断时只需要O(1)。总体还是O(N^2)，比上面的更快。
