# 127. 单词接龙

## 思路

单词即结点，单词间的变换即边，所以问题转化为：在一个无向图中，求起点到终点的最短路径。而求最短路径，就用BFS。

问题1：给定一个单词，怎么找出它能变换的所有单词（或者称为“邻居单词”）？因为该函数在BFS扩展子结点的过程中频繁用到，所以它的实现需要尽可能快。思路有2种：

- 方案1：对于每个单词A，线性遍历单词列表并进行字符串比较，确认它的所有邻居B。
  - 时间：O(N^2 * L)，因为需要二重循环，同时字符串比较需要O(L)，L为字符串长度（根据题目限制，它们等长）。
- 方案2：对于每个单词A，遍历所有潜在邻居B，如果B在给定的单词列表中，则B是其邻居。
  - 时间：O(N * 26 * L) = O(NL)，因为要找潜在邻居，就要遍历每一个位置，只有26种可能（常数）。

所以对于问题1，方案2更好。

问题2：尝试使用BFS的变式来优化时间。

BFS在这里又可以细分为几种写法：

- 正向BFS：从起点出发，寻找终点。只需要1个队列、1个标记（HashSet）。
- 逆向BFS：从终点出发，寻找起点。同上。
- 双向BFS：从起点、终点同时出发，寻找相交点。需要2个队列、2个标记（要用HashMap，因为除了标记是否遍历过，还需要记录步数）。

实际时间依次递减！

## 反思总结

“双向BFS”学到了！
