# 1201. 丑数III

## 题意

给定a、b、c和K，丑数是被a或b或c整除的数字，求第K个丑数。

## 思路

首先是类似于[204. 计数质数](https://leetcode-cn.com/problems/count-primes/)的思路：

- 遍历 + 判断：从n=1开始“死”循环，对于每个数字都判断它能否被a、b、或c整除，是就计数器+1，直到计数器为K。
  - 时间：O(M)，M为答案，所以O(M) > O(K)
- 类似厄拉多塞筛法：丑数通过a、b、c的N倍来找。准备3个指针ai、bi、ci：ai每次走a步，bi每次走b步，ci每次走c步，下一个丑数就是ai、bi、ci中的最小值，以此类推。
  - 时间：O(K)

以上的时间都算是线性复杂度，但这个版本3的丑数的难点在于：K很大，上面的思路都会面临TLE，故只能另辟蹊径。

“第K个丑数”其实就是【第K个数字问题】，对应的解法就是<u>二分查找</u>。可以类比[719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)。这道题的二分查找解法的具体做法是：

1. 确定初始的左右边界，其中右边界取`Math.max(a, b, c) * K`与`2 * 10 ^ 9`的更大值即可。
1. 二分查找，直到区间为空：
    1. 求中间数字middle。
    1. 求middle前面的丑数个数，即小于等于middle的丑数个数，设为C。
    1. 如果C < K，则找右边；如果C >= K，则找左边。

其中，在“求middle前面的丑数个数”时，需要排除重复的丑数（因为重复的丑数只算1个），这需要用到“最小公倍数”。最终计算方式为：

```java
int count = middle / a + middle / b + middle / c // 丑数总个数（有重复）
  - middle / lcm(a, b) - middle / lcm(b, c) - middle / lcm(a, c) // 减去两两重复的
  + middle / lcm(a, b, c) // 但前面多减了3个都重复的，这里补回来
```

时间复杂度分析：二分过程为O(logX)，又因为每一次试探都是O(1)，所以总的时间复杂度为log(X)。而在这道题中，X <= 2 * 10^9，所以O(logX) = O(31)，速度很快。

## 反思总结

线性都超时的搜索问题，考虑用二分查找大大降低时间复杂度。尤其是【第K个数字问题】。

二分查找是真的妙！
