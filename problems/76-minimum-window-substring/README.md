# 76. 最小覆盖子串

## 题意

给定字符串S、T，求S中包含T所有字符的最小字串。

## 思路

首先考虑暴力法：

- 二重循环：外层循环遍历子串的起点位置，内层循环遍历结束位置，每次可获取一个子串
- 判断子串s是否“包含T”，就是一种计数，这里有几种思路，最终采用HashMap：
  - HashMap：对每个字符计数成HashMap，然后比较两个HashMap。O(M)
  - 字符串排序：排序后便于计数。O(MlogM)

这样下来，暴力法的时间复杂度至少为：O(N^3)。先思考该方法有什么地方可以改进：

- 内层循环做的事情是：每次往旧子串s1结尾增加一个字符newChar、得到新子串s2。其实这时HashMap不必重新计算，只需要对newChar计数加1即可。
- 外层循环做的事情是：每次将子串s1的起点后移一位、得到新字串s2，相当于s1减去头字符oldChar，其实这时候HashMap也不必重新计算，只需要对oldChar计数减1。

从这个角度看，外层、内层做的事情相同，都是对字符的新增、删除，而HashMap对这两种操作都是O(1)时间支持，所以二重循环可以变成一重循环，遍历出子串的方式变成了“滑动窗口”。这里要注意一点，用“字符串排序”来判断就无法使用该优化，因为字符串排序后，对任意字符进行增加、删除这两种操作，几乎是无法维护的。

【滑动窗口】的主要做法是用双指针维护一个大小不固定的窗口（子串），右指针增加用以探索可行解，左指针增加用以优化可行解。在这道题中，滑动窗口算法用伪代码表示：

```js
while (right未到终点) {
  ++right;
  newChar计数加1;

  while (能满足) {
    更新答案;
    oldChar计数减1;
    ++left
  }
}
```

即使是最坏情况，左右指针一共移动的次数为2N，所以时间复杂度首先达到O(2N)=O(N)。然后“能满足”这里用的是HashMap来判断：如果是naive判断，则每次都需要O(M)时间，其中M为T的长度；我们可以继续优化，维护一个match变量表示能满足的字符个数，在适当的时候更新，我们就能获取O(1)的判断时间，则总体复杂度为O(N)。
