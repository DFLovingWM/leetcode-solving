# 851. 喧闹和富有

## 题意

给定若干个人之间的富有关系`richer`、以及每个人的低调程度`quietness`。对于每个人，求不比他穷中的人中最低调的那一个。

## 思路

人即结点，富有关系`richer`即边，这是一个图问题，首先构造邻接表。这里分为两种思路。

### 建立到更富者的有向边 + DFS

如果`x`比`y`富有，那么`y`有一条通向`x`的有向边。为什么不是反过来呢？因为我们求的是比一个人更富有的人，所以有向边是通往更富有者的。构造出的有向图，对于一个结点来说，它所在子树中的结点，都不比它穷。所以：

- 朴素思路【TLE】
  - 概述：对于每个结点，都在子树中寻找目标结点
  - 本质：先序遍历
  - 时间复杂度：N个结点需要`O(N)`，每个结点搜索子树需要`O(N)`，所以整体是`O(N^2)`，会超时
- 缓存思路【AC】
  - 概述：朴素思路由于没有利用已求出的信息，所以效率很低。举个例子，富有程度`x > y > 100个人`，那么我们可以先花费`O(100)`时间求出`ans[y]`，然后求`ans[x]`时不需要再看那100个人，而是直接看`ans[y]`，这样时间就变为`O(1)`。在搜索树上体现为“剪枝”：从`x`出发来到结点`y`，由于`ans[y]`已求出，那么在结点`y`处可以直接返回，不必再看`y`子树。
  - 本质：后序遍历；记忆化搜索（可以认为是DP。然而搜索树可能不止一棵，所以严格来说不是DP）
  - 时间复杂度：`O(N)`

神奇的是，构造出来的有向图就是多个搜索树，然后可以在上面进行类似于DP的操作。

### 建立到更穷者的有向边 + 拓扑排序（BFS）

在这群人里面，肯定有至少1个“最”富有的人。把这些人视为第0层，对他们来说，因为没有比他们更富有的人，所以答案是自身`ans[richest] = richest`。

然后，对于“次”富有（第1层）的人`i`来说，`ans[i]`只会在第0、1层之间。依次类推，我们可以使用拓扑排序的思路。

首先，邻接表基于通向更穷者的有向边。然后使用拓扑排序，从“最富者”开始，逐层更新结点的答案（注意，一个人的更富者可能有多个，所以结点的答案是多次迭代更新的结果）。

## 反思总结

我只想说，这道题太棒了。
