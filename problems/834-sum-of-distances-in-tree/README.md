# 834. 树中距离之和

## 思路

### 暴力

暴力思路：从每个结点开始，进行DFS/BFS并累加，最终需要花费`O(N^2)`时间，会超时。

### 优化

设`ans[i]`为结点`i`对应的答案，优化的关键就是利用`ans[x]`和`ans[y]`之间的关系。

考虑两个子树`X``Y`，它们的子根分别是`x``y`，并且`x``y`是相邻的、即它们之间有一条无向边连接着。现在想求`ans[x]`，设`x@X`为结点`x`到`X`子树中的每个结点的路径之和、`#X`为`X`子树的结点数，则有：

（1）`ans[x] = x@X + x@Y = x@X + (1 + y@Y + (#Y - 1)) = x@X + y@Y + #Y`

同理对于`ans[y]`有：

（2）`ans[y] = x@X + y@Y + #X`

两式相减，便得到我们想要的`ans`之间的关系：

（3）`ans[x] - ans[y] = #Y - #X`

也就是说，如果知道了其中一个结点的答案（如`ans[x]`），那么另一个结点的答案（如`ans[y]`）便能通过该公式直接推导出来。

所以，最终的编码思路为：

1. 后序遍历（子推父，基于等式1中的`x@Y = y@Y + #Y`）：对每个结点`i`，求`count[i]`（子树结点数）和`subSum[i]`（子树根到子树中其它所有结点的路径和）。最终求出的`subSum[root]`等于`ans[root]`。这一步，是为了求`ans[root]`。
1. 前序遍历（父推子，基于等式3）：从`ans[root]`出发，用`ans[parent]`推导出`ans[child]`。这一步很明显，就是求剩余的所有`ans[i]`。

参考：https://leetcode.com/problems/sum-of-distances-in-tree/solution/

## 反思总结

学到一个编码细节：当无向图也是一个树时，遍历这个树时需要去重，有两种方式：

- 常规做法：使用集合去重。
- 模拟树遍历：因为树往下遍历时总是能方便获取子结点，在无向图中也可以模拟这种“方向性”，只要在每次扩展子结点时排除父结点即可。

总结：集合去重法对于树而言太繁琐，因为无论是前/中/后序遍历，一个结点只会被遍历一次，根本不需要去重。而这里去的“重”也只有当前结点的父结点这一个结点，所以扩展子（相邻）结点时，把父结点排除掉就可以了。
