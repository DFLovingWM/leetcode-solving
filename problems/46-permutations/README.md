# 46. 全排列

## 题意

给定一个序列`nums`（没有重复数字），返回其所有全排列。

## 思路

有2种思路：

- 思路1（回溯）：每次从剩余数字`nums`中选择1个，直到没有数字可以选的时候，就构成一个排列。我们需要遍历`nums`但是`nums`需要减少/增加，所以最好每次递归前传入`nums`的拷贝，这需要花费`O(N)`时间。另外有一些只需要`O(1)`的方法，但是个人感觉不打安全，不推荐。实现方式有：
  - DFS。维护剩余元素的手段有：
    - 数组copy：copy需要`O(N)`
    - 哈希表(Set)：遍历到第一个不在Set中的元素，也需要`O(N)`
    - 交换：将已选数字放在左边，然后下一次从它之后开始选，只需要`O(1)`
  - BFS（因为第`n+1`层只依赖第`n`层，所以BFS也可用）
- 思路2（循环）：维护一个全排列数组`res`。对于每一个数字，都能加入当前所有全排列，并且是插入到任意一个位置。

## 反思总结

【回溯】模板题。类似题目：

- [78. 子集](https://leetcode-cn.com/problems/subsets/)
