# 862. 和至少为 K 的最短子数组

## 题意

给定数组A和整数K，找出A中和大于K的最短子数组，返回其长度。

## 思路

基本思路：

- 朴素：遍历所有区间，求和，时间复杂度为`O(N^3)`。
- 前缀和优化：提前求和，时间复杂度降低为`O(N^2)`。但还不够。

如果数字都是非负数，那么前缀和数组P就是非递减的，于是就能够使用二分查找进一步把时间降低到`O(NlogN)`。本题存在负数，但同样可以沿用这个思路：维护一个关于P的单调递增的“容器”（抽象概念，且不说如何实现）。为什么可行？考虑这样一种情况：

如果`i < j && P[i] >= P[j]`，那么比起`P[i]`，`P[j]`是更好的减数。因为它更容易满足条件（子数组和更容易达到K）、且答案更优（长度更短）。于是这种情况下，需要淘汰`P[i]`，如此使得容器内的数字单调递增。

这个容器有两种实现方式：

- 双端队列（deque）：`O(N)`
- 有序表（C++ map/set）：`O(NlogN)`
