# 51. N皇后

## 题意

给定`n`，求出`n`皇后问题的所有解。

## 思路

求所有可行解，当然是用回溯算法。然而这里回溯算法有两种：

1. 暴力：穷举所有棋盘，然后判断是否可行。时间为`O(N^N)`，肯定会TLE。
1. 约束编程（聪明而有限的穷举）：逐行放置，对于每一行`i`，遍历所有列`j`，如果放置在`(i, j)`后、与前`i`行已放置的所有皇后都不冲突，则可以选择该位置。时间复杂度分析：第1行有`N`种可能，第2行最多有`N-2`种可能，第3行最多为`N-2-2`，则整体时间大约为`O(N!)`。

在这里当然采用第2种。然后具体到递归函数中：

- 朴素：对于每一个位置`(i, j)`，都遍历前`i`行以检测
- 优化1：哈希表：“检测”一步是重复工作，可以使用哈希表优化（这个套路要做笔记啊考试要考的）。除了二维棋盘`board`，额外设置3个`boolean`哈希表/数组（数组需要保证下标不为负数，哈希表则不需要担忧）：
  - `col`：`col[j]`表示第`j`列是否已有皇后
  - `diagLeft`：`diagLeft[l]`表示从左上角到右下角的第`l`行是否已有皇后，`l`的计算方式：`l = i + j`
  - `diagRight`：`diagRight[r]`表示从右上角到左下角的第`r`行是否已有皇后，`r`的计算方式：`r = i - j + n - 1`
- 优化2：位压缩：将哈希表/数组替换为`bitset`/整数。由于回溯，题目给的`n`不会很大，大概是`n<=12`，就算是乘了2，只用一个32位的整数也是可以存下来的。

优化基于“用空间换时间”的典型思想。不过这道题朴素的回溯也能AC。

## 反思总结

所谓“暴力”/“朴素算法”，是一个相对的概念，它的对立面是“优化”。很多时候，最优解往往是以空间换时间。

在这道题中：

- 在确认回溯思想时，暴力做法是枚举所有解，而非暴力做法是枚举可行解。
- 在递归函数实现中，暴力做法就是对于每一个位置都检测前面的所有皇后，而优化做法是使用哈希表记录。
