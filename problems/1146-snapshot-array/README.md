# 1146. 快照数组

## 思路

本题有两个维度需要考量：数组长度N、平均调用次数K，并且这两个数可能都很大。方案：

- 每次snap，保存整个数组
  - 时间：snap单操作需要O(N)，总体需要O(NK)
  - 空间：O(NK)

该方案会导致TLE。可见，单操作需要小于线性时间，才可能AC。

考虑到<u>snapId是递增的</u>，我们可以对每个数字建立一个快照patch数组，“patch”意味着只保存那些有修改的快照，没有修改的快照不保存。比如`snap`调用了10000次，但是对0位置的元素只有3次修改，那么0的快照数组长这样：

```js
[
  { snapId: 0, value: 0 },
  { snapId: 2, value: 20 },
  { snapId: 7, value: 30 },
  { snapId: 9, value: 0 },
]
```

当`get(index, snapId)`调用时，因为数组中元素的snapId是递增的，所以可以使用二分查找。需要注意的是，如果该snapId不存在（snap次数越多，数组越容易“稀疏”，就越容易发生），比如snapId=8时，返回它前一个位置就好（例子中即snapId=7）。

时间复杂度：

- set: O(1)
- snap: O(1)
- get: O(logS)，其中S为set调用次数，并且有S <= K

于是总体有：

- 时间：O(KlogK)
- 空间：O(N + K)，类似于邻接表
