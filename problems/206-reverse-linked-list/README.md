# 206. 反转链表

## 思路

### 循环法

在左边维护一个已反转的`[head, tail]`区间，`tail`用以探索下一个结点，将其从`head`处插入作为新的`head`。

复杂度：

- 时间：O(N)
- 空间：O(1)

### 递归法

逆序的，都能考虑用递归。细分又有几种不同的思路：

- 后序
  - 重新串联：使用dummy结点重新构建一个链表，然后对链表进行后序遍历，每次处理本结点时就串联起来
  - 返回自身：(为了让两个相邻结点同时出现在一个递归栈中，)回溯时将`curr`作为出参传递给`prev`，让`prev`修改边指向
  - 返回新头部：同上，但是因为`prev`能通过`prev.next`访问`curr`，所以回溯时不必返回`curr`，而总是返回原来的tail（也就是新链表的head）
- 前序：(为了让两个相邻结点同时出现在一个递归栈中，)探索时将`curr`作为入参传递给`next`，让`next`修改边指向

复杂度：

- 时间：O(N)，递归结点数为N
- 空间：O(N)，递归栈深度为N

## 反思总结

练习【链表递归】的入门题/好题。
