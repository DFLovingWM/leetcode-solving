# 87. 扰乱字符串

求A是否是B的扰乱字符串 => 求A、B是否“相似”。

而“相似”的规则是：将字符串不断拆分为两半（左右子树），这两半可以允许互换，最终能够相等。

## DP

状态函数：二维，`f(A, B)`表示A与B是否相似。

设分割点为`i`，先将A拆分为`A[0:i]`（长度为i）、`A[i:N]`（长度为N-i）。那么对于B来说，其实只有两种策略/情况能够表明与A相似：

1. 不交换两半：拆分为`B[0:i]`（长度为i）与`B[i:N]`（长度为N-i），分别与它们俩比较
2. 交换两半：拆分为`B[N-i:N]`（长度为i）与`B[0:N-i]`（长度为N-i），并分别比较

可以看到在比较之前，需要保证「长度」相等。

然后对于每轮递归，O(N)遍历分割点即可，同时如果已经判定为相似，则可以提前退出整个过程，以提高时效。

时间复杂度：O(N^3)
