# 847. 访问所有节点的最短路径

## 思路

搜索问题，并且求最短路，一般用BFS。具体来说：从每个点出发进行BFS，“终点”就是所有点都遍历过了（注意在该过程中，某个点是可以被重复遍历的），于是转化为求“遍历集合”的最短路问题（注意，并非单纯“结点”的最短路问题）。

具体的状态表示还得继续讨论，如下。

### 暴力（TLE）

```c++
struct State {
  unordered_set<int> visited; // 已遍历结点
  int curr; // 当前所在结点
}
```

这是最直观、最容易想到的状态表示。但因为使用了非基本类型，状态无法哈希，也就无法标记该状态是否已遍历。所以一个状态可能被多次访问，对应【回溯】解法，时间复杂度非常大（超时）。

### 使用位压缩优化

对于每个结点来说，只有“未遍历”与“已遍历”两种状态，可以用0/1表示。同时，题目限制了N最大为12，所以总状态数最大也就达到`2^12`，整型是可以存下来的，于是使用【位压缩】来代替上面的`unordered_set`（集合）。状态改为：

```c++
struct State {
  int cover; // 已遍历结点（位压缩）
  int i; // 当前所在结点
}
```

为了标记一个状态是否已遍历，有两种方式：

```c++
bool visit[1 << N][N]; // 是否已遍历
int dist[1 << N][N]; // 遍历的最小距离
```

在本题中这两种表示方式是一样的（不过有时候不一样，例如1293题），这个就不讨论了。标记的存在，表面上是去重，本质上是缓存了子问题的最优解，对应【动态规划】解法，时间复杂度为`O(N * 2^N)`。

## 反思总结

在包括该题在内的最短路问题中，BFS蕴含了DP思想。所以该题不但能用BFS解，还能用DP解。

推荐一道题干不大相同，但编码思路非常类似的题目：

- [1293. 网格中的最短路径](https://leetcode-cn.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/)
