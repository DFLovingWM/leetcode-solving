# 644. 最大平均子段和 II

## 思路

### 暴力法

遍历起点，遍历子数组长度，需要O(N^2)时间，必定TLE。

### 二分查找法（又没想到吧？！）

二分枚举最大平均值`mid`，检验是否存在平均值【大于等于】`mid`的子数组。

关键是如何保证“校验”这一步的时间复杂度至多为O(N)？构建前缀数组`prefix`：

> prefix[i] = prefix[i-1] + nums[i-1] - mid

其中`prefix[i]`表示`nums[0] + nums[1] + ... + nums[i-1] - i * mid`，所以如果`prefix[i] >= 0`说明`nums[0]～nums[i-1]`这段子数组的平均数大于等于`mid`。同理，如果`prefix[i] - prefix[j] >= 0`，说明`nums[j]～nums[i-1]`这段子数组的平均数大于等于`mid`。对于`prefix[i]`来说，只需要找到`0 ～ i-K`中的最小值即可，于是我们维护一个`min`表示之前最小的`prefix`值，当`prefix[i] >= min`时就找到了。整个过程就是一次遍历，所以是O(N)。

二分细节：因为涉及到小数，所以二分时不再是`left = mid + 1`而是`left = mid`，二分的循环条件也变成`right - left > 1e-5`（题目限制）。综上，时间复杂度为`O(N * log(X * 1e5))`。
