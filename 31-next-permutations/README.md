# 31

## 题意

给定一个序列，求这个序列的下一个序列（遍历的顺序按照升序排列）。

## 方法

- 暴力法(但是题目要求O(1)的空间复杂度，所以该方法不能用)：还原递归过程。这里可能会想到两种子思路：
  - 搜索到目标序列的下一个序列就终止。然而会发现，虽然不像搜索全部序列那么耗时，但当序列重复的时候，这种办法就行不通了。
  - 所以，只能老实地搜索出全部序列，然后进行去重，最后找 target 的下一个序列。
- 找规律法：从尾部开始寻找逆序数组A，记数组左边的元素为B，把A中比B刚好大一点的值C与B交换；然后将A变为正序，可以采用：
  - 排序：O(NlogN)，更“保险”
  - 逆转(reverse)：O(N)，更快，但需要处理好更多细节：
    - 逆转算法中的下标右边界。如果控制不好可能会造成“逆转再逆转 => 没有变化”。
    - 因为逆转的前提是：将B交换进来后A仍为逆序。所以找C时需要从右边找起，只要是第一个比B大的，就是它了。

## 细节处理

需要考虑逆序数组中有重复元素的情况，比如：

> S1 = [1, 2, 3, 3, 3]

我们手动找出 S1 的下一个序列应该是

> S2 = [1, 3, 2, 3, 3]

所以可以反推出逆序数组应该是：A = [3, 3, 3]，而不只是[ 3 ]，然后：B = 2。