# 5214. 最长定差子序列

## 思路

> 1、动态规划

简单的动态规划（说简单是因为没有太多动态规划的味道），设`dp[N]`为以数字N结尾的序列的最长长度，则有状态转移思路：

- 如果存在`dp[n - d]`，则更新为`dp[n - d] + 1`（拼到已有序列）
- 否则，更新为1（重起序列）

考虑到N可以是负数，数组不大好操作，所以推荐用`HashMap`。

算法复杂度：

- 时间：O(N)
- 空间：O(N)

> 2、二分查找

提前遍历，维护一个关于数字的下标数组（升序）。

然后对于每一个数字`arr[i]`，循环地寻找`n + diff`的大于`i`的最小下标，即`bisectLeft(indexList.get(n + diff), i + 1)`，直到找不到为止，就形成一个序列。

优化：对于某个数字j来说，如果它被前面的数字i遍历到了，那么j就不用作为数列的起点再遍历了。可以利用`HashSet`标记已遍历数字。

复杂度：

- 时间：最坏为O(N^2)，即二分查找没有成功的，每个数字都是一个独立的等差数列。如果没有用HashSet优化，则复杂度恒为O(N^2)，导致TLE。
- 空间：O(N)，记录所有下标

## 反思总结

如果题目没有给出`difference`，求的不再是“定差”、而是“等差”，又怎么解？

还是用动态规划，设`dp[i][diff]`为第i个数字所在的差为`diff`的等差数列的长度，然后进行二重循环。
