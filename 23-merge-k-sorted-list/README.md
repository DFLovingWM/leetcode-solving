# 23. 合并K个有序链表

## 题意

给定K个有序单链表，将它们合并为一个有序单链表，返回新链表的head结点。

## 思路

### 1. 常规思路

主要思路是：从K个结点中选取最小val的那一个追加到新链表后面，重复该过程。

<u>Naive</u>：遍历得到最小值，这个过程需要O(K)时间，所以有：

- 时间：O(NK)
- 空间：O(1)

然后我们可以发现，我们遍历了K个结点后，只取走一个结点，剩下的(K-1)个结点是没有变的，但还是要参与下一次的O(K)遍历，于是这里其实可以通过数据结构来优化。要用什么数据结构呢？我们想一下需求：

- 获取最小值
- 删除最小值
- 增加新元素

如果要快速完成这几种操作，其中一个选择就是：小顶堆（延伸的数据结构：优先队列/PriorityQueue）！

<u>小顶堆</u>：维护一个小顶堆，大小最多为K（因为一旦有一个单链表遍历完了，堆的大小就小于K了）。每次弹出最小值，追加到新链表，然后将它的next结点再加入堆中：

- 时间：O(NlogK)
- 空间：O(K)

除了小顶堆，还有一个数据结构可以满足，就是有序表（延伸的数据结构：TreeMap）：

<u>有序表</u>：维护一个大小最多为K的有序表（BST/AVL/RB实现）：

- 时间：O(NlogK)
- 空间：O(K)

### 2. 其它思路

#### 全排序

把所有链表结点都放在一个大数组中，然后进行排序，最后再转化为链表。这种方法很无脑，因因为无视了各自有序这个条件：

- 时间：O(NlogN)。但在N比较大、K较小的情况下，时效可能比暴力还要差。
- 空间：O(logN)。

#### 分治

K个链表合并，可以拆分为2个问题：

- 2个链表合并为1个新链表
- 将上面过程重复(K-1)次

复杂度：

- 时间：O(KL)，@todo：存疑
- 空间：O(1)

## 参考

- [解题思路](https://leetcode.com/problems/merge-k-sorted-lists/solution/)
